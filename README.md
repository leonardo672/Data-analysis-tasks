# Data-analysis-tasks

## Блок 1: Теория вероятности и логика 
### Задание №1: Фермер
На ферме содержатся **6 разных видов животных**.  
Каждый раз, когда фермер заходит в сарай, он видит **одно случайное животное**.  
За день фермер заходит в сарай **6 раз**.
Найти математическое ожидание количества **разных видов животных**, которых фермер увидит за день.

### Шаги решения:

Рассмотрим один фиксированный вид животного.

Вероятность **не увидеть** его за один заход: `5 / 6`  

Вероятность **не увидеть** его за 6 независимых заходов:  `(5 / 6)⁶`

Вероятность увидеть этот вид **хотя бы один раз**:  `1 − (5 / 6)⁶`

Так как всего видов животных **6**, математическое ожидание количества различных видов: `E = 6 × (1 − (5 / 6)⁶)`

Вычисления:
  - ``(5 / 6)⁶ = 15625 / 46656 ≈ 0.3349``  
  - ``E = 6 × (1 − 0.3349)``  
  - ``E = 6 × 0.6651 ≈ **3.99**``

Ответ: **3.99**

-------

### Задание №2: Кулинарное соревнование

В конкурсе участвуют 80 шеф-поваров с уникальными уровнями мастерства. В первом этапе судьи случайным образом распределяют их по парам (в любом состязании двух шефов выигрывает тот, у кого выше уровень мастерства). На втором этапе шефы снова случайно образуют пары для финального раунда (пары могут повториться). Победную награду получают те, кто выиграл в обоих этапах.
Каково математическое ожидание числа победителей?

### Шаги решения:

1. Рассмотрим шефа ранга `k`.  
   - Сильнее него: `k−1` шеф  
   - Слабее него: `80−k` шефов  
   - Вероятность победы в одном раунде: `(80−k)/79`

2. Раунды независимы, поэтому вероятность победы в обоих раундах: `((80−k)/79)^2`

3. Математическое ожидание числа двойных победителей:
   
   ```E[X] = сумма по k=1..80 ((80−k)/79)^2```

4. Подставим:
   
```
j = 80−k, тогда j = 0..79:
E[X] = (1/79^2) * сумма j=0..79 (j^2)
```

5. Сумма квадратов чисел от `0` до `79`:

 ```сумма j^2 = 7980159 / 6 = 167480```

6. Следовательно:
   
```E[X] = 167480 / 6241 ≈ 26,8```

Ответ: **26,8**

----------

### Задание №3: Одинокая дорога

На пустынном шоссе вероятность появления автомобиля за `30` минут составляет `0,95`. Найти вероятность появления автомобиля за `10` минут и за `27` минут.

### Шаги решения:

1. Пусть событие появления автомобиля подчиняется **плотности Пуассона / экспоненциальному закону времени между событиями**.  
   - Вероятность появления за `t` минут:
     `P(t) = 1 − exp(−λ * t)`

2. Найдём `λ` по условию на `30` минут:
    - `0,95 = 1 − exp(−λ * 30)`
    - `exp(−30λ) = 0,05`
    - `λ = −ln(0,05) / 30 ≈ 0,09986`

4. Вероятность появления за `10` минут:
    - `P(10) = 1 − exp(−0,09986 * 10) ≈ 0,6321 ≈ 63,2%`

5. Вероятность появления за `27` минут:
    - `P(27) = 1 − exp(−0,09986 * 27) ≈ 0,9308 ≈ 93,1%`

Ответ: **63,2; 93,1**

---------

## Блок 2: Python 

### Задание №1: Изоморфизмы
Реализовать функцию (или тело функции), которая проверяет на изоморфность два слова.
Пояснение: строки `s` и `t` называются изоморфными, если все вхождения каждого символа строки `s` можно последовательно заменить другим символом и получить строку `t`. Порядок символов при этом должен сохраняться, а замена — быть уникальной. Так, два разных символа строки `s` нельзя заменить одним и тем же символом из строки `t`, а вот одинаковые символы в строке `s` должны заменяться одним и тем же символом.
Пример:
```
s = 'paper' 
t = 'title' 
print(is_isomorphic(s, t))
```
Вывод: `True`
Оценить оптимальность решения по времени и памяти и прикрепить текст кода.

### решения:

```
def is_isomorphic(s: str, t: str) -> bool:
    if len(s) != len(t):
        return False

    map_st = {}
    map_ts = {}

    for c1, c2 in zip(s, t):
        # Check s → t mapping
        if c1 in map_st:
            if map_st[c1] != c2:
                return False
        else:
            map_st[c1] = c2

        # Check t → s mapping (to enforce uniqueness)
        if c2 in map_ts:
            if map_ts[c2] != c1:
                return False
        else:
            map_ts[c2] = c1

    return True
```

----------

### Задание №2: Натуральная последовательность
Реализовать функцию (или тело функции), которая находит единственное отсутствующее число из последовательности натуральных чисел `1,2,…,n.`
Пример:
```
nums = [1, 2, 3, 4, 5, 6, 8, 9, 10, 11]
print(missing_number(nums))
```
Вывод: 7
Оценить оптимальность решения по времени и памяти и прикрепить текст кода.

### решения: 
```
def missing_number(nums):
    n = len(nums) + 1      # since one number is missing
    expected_sum = n * (n + 1) // 2
    actual_sum = sum(nums)
    return expected_sum - actual_sum
```

----------

### Задание №3: Факторизация
Реализовать функцию (или тело функции), которая при введении натурального числа n разбивает его на простые множители (представить его в виде произведения простых чисел).
Пример:
```
n = 56
print(prime_factors(n))
```
Вывод:
```
[2, 2, 2, 7]
```
Оценить оптимальность решения по времени и памяти и прикрепить текст кода.

### решения: 
```
def prime_factors(n: int):
    factors = []

    # Extract all factors of 2
    while n % 2 == 0:
        factors.append(2)
        n //= 2

    # Check only odd numbers up to sqrt(n)
    p = 3
    while p * p <= n:
        while n % p == 0:
            factors.append(p)
            n //= p
        p += 2

    # If n is still > 1, it is prime
    if n > 1:
        factors.append(n)

    return factors
```

## Блок 3: SQL
### Задание №1: Абитуриенты
Есть таблица examination с двумя полями: `id (id абитуриента)`, `scores (кол-во набранных баллов дополнительного вступительного испытания от 0 до 100)`.
Требуется реализовать запрос, который создаёт колонку с позицией абитуриента в общем рейтинге.

### решения: 
```
SELECT
    id,
    scores,
    RANK() OVER (ORDER BY scores DESC) AS position
FROM examination;
```

-------------

Задание №2: `FULL JOIN`
Представьте две таблицы: первая содержит `30` строк, а вторая — `20` строк. Мы выполняем операцию `FULL JOIN` между ними.
Какой диапазон возможного количества строк может быть в результирующей таблице, если учесть, что ключи для соединения могут быть как полностью совпадающими, так и абсолютно уникальными?
Ответ дать в краткой форме, например: минимально `10` и максимально `3000` строк.

### решения: 
```
Минимум — 30, максимум — 600
```

-------

# Задание №3: Одинокая дорога

**Условие:**  
На пустынном шоссе вероятность появления автомобиля за 30-минутный период составляет 0.95. Какова вероятность его появления за 10 минут? А за 27 минут?  
Ответ дать в процентах, округлив до десятых через точку с запятой.

---

### 1. Анализ задачи
Событие "появление автомобиля" на временном промежутке, по всей видимости, является случайным и редким. Разумно предположить, что процесс появления автомобилей подчиняется **распределению Пуассона**, где события независимы и происходят с некоторой постоянной средней интенсивностью \( \lambda \) (число событий в единицу времени).

Вероятность появления **хотя бы одного** автомобиля за время \( t \) в пуассоновском процессе с интенсивностью \( \lambda \) вычисляется по формуле:
\[
P(t) = 1 - e^{-\lambda t}
\]

---

### 2. Нахождение интенсивности \( \lambda \)
Из условия известно:  
\[
P(30) = 1 - e^{-30\lambda} = 0.95
\]
Решим уравнение:
\[
e^{-30\lambda} = 1 - 0.95 = 0.05
\]
\[
-30\lambda = \ln(0.05)
\]
\[
\lambda = -\frac{\ln(0.05)}{30} \approx -\frac{(-2.995732)}{30} \approx \frac{2.995732}{30} \approx 0.0998577 \text{ (в минутах}^{-1}\text{)}
\]

---

### 3. Вероятность за 10 минут
\[
P(10) = 1 - e^{-\lambda \cdot 10} = 1 - e^{-0.0998577 \cdot 10} = 1 - e^{-0.998577}
\]
\[
e^{-0.998577} \approx 0.3686 \quad (\text{точнее: } e^{-0.998577} \approx 0.3684)
\]
\[
P(10) \approx 1 - 0.3684 = 0.6316
\]
В процентах: \( 63.16\% \). Округляем до десятых: **63,2%**.

---

### 4. Вероятность за 27 минут
\[
P(27) = 1 - e^{-\lambda \cdot 27} = 1 - e^{-0.0998577 \cdot 27} = 1 - e^{-2.696158}
\]
\[
e^{-2.696158} \approx 0.06754
\]
\[
P(27) \approx 1 - 0.06754 = 0.93246
\]
В процентах: \( 93.246\% \). Округляем до десятых: **93,2%**.

---

### 5. Ответ
Вероятность появления автомобиля:  
- за **10 минут**: ≈ **63,2%**;  
- за **27 минут**: ≈ **93,2%**.

**Итоговая строка для ответа:**


