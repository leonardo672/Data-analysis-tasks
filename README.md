# Data-analysis-tasks

## Блок 1: Теория вероятности и логика 
### Задание №1: Фермер
На ферме содержатся **6 разных видов животных**.  
Каждый раз, когда фермер заходит в сарай, он видит **одно случайное животное**.  
За день фермер заходит в сарай **6 раз**.
Найти математическое ожидание количества **разных видов животных**, которых фермер увидит за день.

### Шаги решения:

Рассмотрим один фиксированный вид животного.

Вероятность **не увидеть** его за один заход: `5 / 6`  

Вероятность **не увидеть** его за 6 независимых заходов:  `(5 / 6)⁶`

Вероятность увидеть этот вид **хотя бы один раз**:  `1 − (5 / 6)⁶`

Так как всего видов животных **6**, математическое ожидание количества различных видов: `E = 6 × (1 − (5 / 6)⁶)`

Вычисления:
  - ``(5 / 6)⁶ = 15625 / 46656 ≈ 0.3349``  
  - ``E = 6 × (1 − 0.3349)``  
  - ``E = 6 × 0.6651 ≈ **3.99**``

Ответ: **3.99**

-------

### Задание №2: Кулинарное соревнование

В конкурсе участвуют 80 шеф-поваров с уникальными уровнями мастерства. В первом этапе судьи случайным образом распределяют их по парам (в любом состязании двух шефов выигрывает тот, у кого выше уровень мастерства). На втором этапе шефы снова случайно образуют пары для финального раунда (пары могут повториться). Победную награду получают те, кто выиграл в обоих этапах.
Каково математическое ожидание числа победителей?

### Шаги решения:

1. Рассмотрим шефа ранга `k`.  
   - Сильнее него: `k−1` шеф  
   - Слабее него: `80−k` шефов  
   - Вероятность победы в одном раунде: `(80−k)/79`

2. Раунды независимы, поэтому вероятность победы в обоих раундах: `((80−k)/79)^2`

3. Математическое ожидание числа двойных победителей:
   
   ```E[X] = сумма по k=1..80 ((80−k)/79)^2```

4. Подставим:
   
```
j = 80−k, тогда j = 0..79:
E[X] = (1/79^2) * сумма j=0..79 (j^2)
```

5. Сумма квадратов чисел от `0` до `79`:

 ```сумма j^2 = 7980159 / 6 = 167480```

6. Следовательно:
   
```E[X] = 167480 / 6241 ≈ 26,8```

Ответ: **26,8**

----------

### Задание №3: Одинокая дорога

На пустынном шоссе вероятность появления автомобиля за `30` минут составляет `0,95`. Найти вероятность появления автомобиля за `10` минут и за `27` минут.

### Шаги решения:

1. Пусть событие появления автомобиля подчиняется **плотности Пуассона / экспоненциальному закону времени между событиями**.  
   - Вероятность появления за `t` минут:
     `P(t) = 1 − exp(−λ * t)`

2. Найдём `λ` по условию на `30` минут:
    - `0,95 = 1 − exp(−λ * 30)`
    - `exp(−30λ) = 0,05`
    - `λ = −ln(0,05) / 30 ≈ 0,09986`

4. Вероятность появления за `10` минут:
    - `P(10) = 1 − exp(−0,09986 * 10) ≈ 0,6321 ≈ 63,2%`

5. Вероятность появления за `27` минут:
    - `P(27) = 1 − exp(−0,09986 * 27) ≈ 0,9308 ≈ 93,1%`

Ответ: **63,2; 93,1**

---------

## Блок 2: Python 

### Задание №1: Изоморфизмы
Реализовать функцию (или тело функции), которая проверяет на изоморфность два слова.
Пояснение: строки `s` и `t` называются изоморфными, если все вхождения каждого символа строки `s` можно последовательно заменить другим символом и получить строку `t`. Порядок символов при этом должен сохраняться, а замена — быть уникальной. Так, два разных символа строки `s` нельзя заменить одним и тем же символом из строки `t`, а вот одинаковые символы в строке `s` должны заменяться одним и тем же символом.
Пример:
```
s = 'paper' 
t = 'title' 
print(is_isomorphic(s, t))
```
Вывод: `True`
Оценить оптимальность решения по времени и памяти и прикрепить текст кода.

### решения:

```
def is_isomorphic(s: str, t: str) -> bool:
    if len(s) != len(t):
        return False

    map_st = {}
    map_ts = {}

    for c1, c2 in zip(s, t):
        # Check s → t mapping
        if c1 in map_st:
            if map_st[c1] != c2:
                return False
        else:
            map_st[c1] = c2

        # Check t → s mapping (to enforce uniqueness)
        if c2 in map_ts:
            if map_ts[c2] != c1:
                return False
        else:
            map_ts[c2] = c1

    return True
```

----------

### Задание №2: Натуральная последовательность
Реализовать функцию (или тело функции), которая находит единственное отсутствующее число из последовательности натуральных чисел `1,2,…,n.`
Пример:
```
nums = [1, 2, 3, 4, 5, 6, 8, 9, 10, 11]
print(missing_number(nums))
```
Вывод: 7
Оценить оптимальность решения по времени и памяти и прикрепить текст кода.

### решения: 
```
def missing_number(nums):
    n = len(nums) + 1      # since one number is missing
    expected_sum = n * (n + 1) // 2
    actual_sum = sum(nums)
    return expected_sum - actual_sum
```







